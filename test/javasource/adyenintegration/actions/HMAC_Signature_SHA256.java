// This file was generated by Mendix Business Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package adyenintegration.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import java.nio.charset.Charset;
import java.security.SignatureException;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import com.google.common.io.BaseEncoding;

/**
 * 
 */
public class HMAC_Signature_SHA256 extends CustomJavaAction<String>
{
	private String HMAC_Key;
	private String merchantReference;
	private String paymentAmount;
	private String currencyCode;
	private String shipBeforeDate;
	private String skinCode;
	private String sessionValidity;
	private String merchantReturnData;
	private String shopperEmail;
	private String merchantAccount;

	public HMAC_Signature_SHA256(IContext context, String HMAC_Key, String merchantReference, String paymentAmount, String currencyCode, String shipBeforeDate, String skinCode, String sessionValidity, String merchantReturnData, String shopperEmail, String merchantAccount)
	{
		super(context);
		this.HMAC_Key = HMAC_Key;
		this.merchantReference = merchantReference;
		this.paymentAmount = paymentAmount;
		this.currencyCode = currencyCode;
		this.shipBeforeDate = shipBeforeDate;
		this.skinCode = skinCode;
		this.sessionValidity = sessionValidity;
		this.merchantReturnData = merchantReturnData;
		this.shopperEmail = shopperEmail;
		this.merchantAccount = merchantAccount;
	}

	@Override
	public String executeAction() throws Exception
	{
		// BEGIN USER CODE

	 
	         
	        byte[] hmacKey =  BaseEncoding.base16().decode("4468D9782DEF54FCD706C9100C71EC43932B1EBC2ACF6BA0560C05AAA7550C48");
	 
	        // Sort order is important (using natural ordering)
	        SortedMap<String, String> params = new TreeMap<>();
	        params.put("merchantReference", merchantReference);
	        params.put("paymentAmount", paymentAmount);
	        params.put("currencyCode", currencyCode);
	        params.put("shipBeforeDate", shipBeforeDate);
	        params.put("skinCode", skinCode);
	        params.put("merchantAccount", merchantAccount);
	        
	        
	        params.put("sessionValidity", sessionValidity);

	        params.put("shopperEmail", shopperEmail);
	        params.put("merchantReturnData", merchantReturnData);
	 
	        // Calculate the data to sign
	        String signingData = Stream.concat(params.keySet().stream(), params.values().stream())
	                .map(HMAC_Signature_SHA256::escapeVal)
	                .collect(Collectors.joining(":"));
	 
	        // Create the signature and add it to the parameter map
	        try {
	            return calculateHMAC(signingData, hmacKey);
	        } catch (SignatureException e) {
	            e.printStackTrace();
	            return null;
	        }

	 
	   
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public String toString()
	{
		return "HMAC_Signature_SHA256";
	}

	// BEGIN EXTRA CODE
	 private static String escapeVal(String val) {
	        if(val == null) { return ""; }
	        return val.replace("\\", "\\\\").replace(":", "\\:");
	    }
	     
	    private static String calculateHMAC(String data, byte[] key)  throws java.security.SignatureException {
		    final String HMAC_SHA256_ALGORITHM = "HmacSHA256";
		    final Charset C_UTF8 = Charset.forName("UTF8");
	        try {
	            // Create an hmac_sha256 key from the raw key bytes
	            SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA256_ALGORITHM);
	 
	            // Get an hmac_sha256 Mac instance and initialize with the signing key
	            Mac mac = Mac.getInstance(HMAC_SHA256_ALGORITHM);
	            mac.init(signingKey);
	 
	            // Compute the hmac on input data bytes
	            byte[] rawHmac = mac.doFinal(data.getBytes(C_UTF8));
	 
	            // Base64-encode the hmac
	            return  BaseEncoding.base64().encode(rawHmac);
	 
	        } catch (Exception e) {
	            throw new SignatureException("Failed to generate HMAC : " + e.getMessage());
	        }
	    }
	// END EXTRA CODE
}
